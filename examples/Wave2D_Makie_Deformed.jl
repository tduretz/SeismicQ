using SeismicQ, FastBroadcast, GLMakie, Printf, Colors, ColorSchemes, MathTeXEngine, UnPack, Makie.GeometryBasics
Makie.update_theme!(fonts = (regular = texfont(), bold = texfont(:bold), italic = texfont(:italic)))

@views h(x,A,œÉ,b,x0)    = A*exp(-(x-x0)^2/œÉ^2) + b
@views dhdx(x,A,œÉ,b,x0) = -2*x/œÉ^2*A*exp(-(x-x0).^2/œÉ^2)


function Mesh_y( X, A, x0, œÉ, b, m, ymin0, ymax0, œÉy )
    y0    = ymax0
    ymin1 = (sinh.( œÉy.*(ymin0.-y0) ))
    ymax1 = (sinh.( œÉy.*(ymax0.-y0) ))
    sy    = (ymax0-ymin0)/(ymax1-ymin1)
    y     = (sinh.( œÉy.*(X[2].-y0) )) .* sy  .+ y0
    # y = X[2]
    z0    = -(A*exp(-(X[1]-x0)^2/œÉ^2) + b) # topography height
    y     = (y/ymin0)*((z0+m))-z0        # shift grid vertically
    return y
end
function Mesh_x( X, A, x0, œÉ, b, m, xmin0, xmax0, œÉx )
    xmin1 = (sinh.( œÉx.*(xmin0.-x0) ))
    xmax1 = (sinh.( œÉx.*(xmax0.-x0) ))
    sx    = (xmax0-xmin0)/(xmax1-xmin1)
    x     = (sinh.( œÉx.*(X[1].-x0) )) .* sx  .+ x0        
    # x   = X[1]
    return x
end

function PatchPlotMakie(vertx, verty, field; cmap = :turbo, write_fig=false )
    f    = GLMakie.Figure(resolution = (1200, 1000))
    xmin = minimum(vertx)
    xmax = maximum(vertx)
    ymin = minimum(verty)
    ymax = maximum(verty)
    ar = (xmax - xmin) / (ymax - ymin)
    GLMakie.Axis(f[1,1]) #, aspect = ar
    min_v = minimum( field ); max_v = maximum( field )
    limits = min_v ‚âà max_v ? (min_v, min_v + 1) : (min_v, max_v)
    p = [Polygon( Point2f0[ (vertx[i,j], verty[i,j]) for j=1:4] ) for i in 1:length(field)]
    GLMakie.poly!(p, color = field, colormap = cmap, strokewidth = 1, strokecolor = :black, markerstrokewidth = 0, markerstrokecolor = (0, 0, 0, 0), aspect=:image, colorrange=limits)
    GLMakie.Colorbar(f[1, 2], colormap = cmap, limits=limits, flipaxis = true, size = 25 )
    display(f)
    # if write_fig==true 
    #     FileIO.save( string(@__DIR__, "/plot.png"), f)
    # end
    return nothing
end

function InverseJacobian!(‚àÇŒæ,‚àÇŒ∑,‚àÇx,‚àÇy)
    M = zeros(2,2)
    @time for i in eachindex(‚àÇŒæ.‚àÇx)
        M[1,1]   = ‚àÇx.‚àÇŒæ[i]
        M[1,2]   = ‚àÇx.‚àÇŒ∑[i]
        M[2,1]   = ‚àÇy.‚àÇŒæ[i]
        M[2,2]   = ‚àÇy.‚àÇŒ∑[i]
        invJ     = inv(M)
        ‚àÇŒæ.‚àÇx[i] = invJ[1,1]
        ‚àÇŒæ.‚àÇy[i] = invJ[1,2]
        ‚àÇŒ∑.‚àÇx[i] = invJ[2,1]
        ‚àÇŒ∑.‚àÇy[i] = invJ[2,2]
    end
    @printf("min(‚àÇŒæ‚àÇx) = %1.6f --- max(‚àÇŒæ‚àÇx) = %1.6f\n", minimum(‚àÇŒæ.‚àÇx), maximum(‚àÇŒæ.‚àÇx))
    @printf("min(‚àÇŒæ‚àÇy) = %1.6f --- max(‚àÇŒæ‚àÇy) = %1.6f\n", minimum(‚àÇŒæ.‚àÇy), maximum(‚àÇŒæ.‚àÇy))
    @printf("min(‚àÇŒ∑‚àÇx) = %1.6f --- max(‚àÇŒ∑‚àÇx) = %1.6f\n", minimum(‚àÇŒ∑.‚àÇx), maximum(‚àÇŒ∑.‚àÇx))
    @printf("min(‚àÇŒ∑‚àÇy) = %1.6f --- max(‚àÇŒ∑‚àÇy) = %1.6f\n", minimum(‚àÇŒ∑.‚àÇy), maximum(‚àÇŒ∑.‚àÇy))
    return nothing
end

function ComputeForwardTransformation_ini!( ‚àÇx, ‚àÇy, x_ini, y_ini, X_msh, Amp, x0, œÉ, m, x, y, œÉx, œÉy, œµ)
    
    xmin, xmax = x.min, x.max
    ymin, ymax = y.min, y.max

    @time for i in eachindex(y_ini)          
    
        # compute dxdksi
        X_msh[1] = x_ini[i]-œµ
        X_msh[2] = y_ini[i] 
        xm       = Mesh_x( X_msh,  Amp, x0, œÉ, xmax, m, xmin, xmax, œÉx )
        # --------
        X_msh[1] = x_ini[i]+œµ
        X_msh[2] = y_ini[i]
        xp       = Mesh_x( X_msh,  Amp, x0, œÉ, xmax, m, xmin, xmax, œÉx )
        # --------
        ‚àÇx.‚àÇŒæ[i] = (xp - xm) / (2œµ)
    
        # compute dydeta
        X_msh[1] = x_ini[i]
        X_msh[2] = y_ini[i]-œµ
        xm     = Mesh_x( X_msh,  Amp, x0, œÉ, ymax, m, ymin, ymax, œÉy )
        # --------
        X_msh[1] = x_ini[i]
        X_msh[2] = y_ini[i]+œµ
        xp       = Mesh_x( X_msh,  Amp, x0, œÉ, ymax, m, ymin, ymax, œÉy )
        # --------
        ‚àÇx.‚àÇŒ∑[i] = (xp - xm) / (2œµ)
    
        # compute dydksi
        X_msh[1] = x_ini[i]-œµ
        X_msh[2] = y_ini[i] 
        ym       = Mesh_y( X_msh,  Amp, x0, œÉ, ymax, m, ymin, ymax, œÉy )
        # --------
        X_msh[1] = x_ini[i]+œµ
        X_msh[2] = y_ini[i]
        yp       = Mesh_y( X_msh,  Amp, x0, œÉ, ymax, m, ymin, ymax, œÉy )
        # --------
        ‚àÇy.‚àÇŒæ[i] = (yp - ym) / (2œµ)
    
        # compute dydeta
        X_msh[1] = x_ini[i]
        X_msh[2] = y_ini[i]-œµ
        ym     = Mesh_y( X_msh,  Amp, x0, œÉ, ymax, m, ymin, ymax, œÉy )
        # --------
        X_msh[1] = x_ini[i]
        X_msh[2] = y_ini[i]+œµ
        yp     = Mesh_y( X_msh,  Amp, x0, œÉ, ymax, m, ymin, ymax, œÉy )
        # --------
        ‚àÇy.‚àÇŒ∑[i] = (yp - ym) / (2œµ)
    end
    # #################
    # # ForwardDiff
    # g = zeros(2)
    # Y = zeros(1)
    # dydksi_FD = zeros(size(dydeta))
    # dydeta_FD = zeros(size(dydeta))
    # dxdksi_FD = zeros(size(dydeta))
    # dxdeta_FD = zeros(size(dydeta))
    # @time for i in eachindex(dydeta_FD)
    #     X_msh[1] = x_ini[i]
    #     X_msh[2] = y_ini[i]
    #     Mesh_y_closed = (X_msh) -> Mesh_y( X_msh, Amp, x0, œÉ, b, m, ymin )
    #     ForwardDiff.gradient!( g, Mesh_y_closed, X_msh )
    #     dydksi_FD[i] = g[1]
    #     dydeta_FD[i] = g[2]
    #     Meshx_surf_closed = (X_msh) -> Mesh_x( X_msh, Amp, x0, œÉ, b, m, ymin )
    #     ForwardDiff.gradient!( g, Meshx_surf_closed, X_msh )
    #     dxdksi_FD[i] = g[1]
    #     dxdeta_FD[i] = g[2]
    # end
    
    # dxdksi_num = diff(xv4,dims=1)/(Œîx/2)
    # dxdeta_num = diff(xv4,dims=2)/(Œîy/2)
    # dydksi_num = diff(yv4,dims=1)/(Œîx/2)
    # dydeta_num = diff(yv4,dims=2)/(Œîy/2)
    
    # @printf("min(dxdksi    ) = %1.6f --- max(dxdksi    ) = %1.6f\n", minimum(dxdksi   ), maximum(dxdksi   ))
    # @printf("min(dxdksi_FD ) = %1.6f --- max(dxdksi_FD ) = %1.6f\n", minimum(dxdksi_FD), maximum(dxdksi_FD))
    # @printf("min(dxdksi_num) = %1.6f --- max(dxdksi_num) = %1.6f\n", minimum(dxdksi_num), maximum(dxdksi_num))
    
    # @printf("min(dxdeta    ) = %1.6f --- max(dxdeta   ) = %1.6f\n", minimum(dxdeta   ), maximum(dxdeta   ))
    # @printf("min(dxdeta_FD ) = %1.6f --- max(dxdeta_FD) = %1.6f\n", minimum(dxdeta_FD), maximum(dxdeta_FD))
    # @printf("min(dxdeta_num) = %1.6f --- max(dxdeta_num) = %1.6f\n", minimum(dxdeta_num), maximum(dxdeta_num))
    
    # @printf("min(dydksi    ) = %1.6f --- max(dydksi    ) = %1.6f\n", minimum(dydksi   ), maximum(dydksi   ))
    # @printf("min(dydksi_FD ) = %1.6f --- max(dydksi_FD ) = %1.6f\n", minimum(dydksi_FD), maximum(dydksi_FD))
    # @printf("min(dydksi_num) = %1.6f --- max(dydksi_num) = %1.6f\n", minimum(dydksi_num), maximum(dydksi_num))
    
    # @printf("min(dydeta    ) = %1.6f --- max(dydeta    ) = %1.6f\n", minimum(dydeta   ), maximum(dydeta   ))
    # @printf("min(dydeta_FD ) = %1.6f --- max(dydeta_FD ) = %1.6f\n", minimum(dydeta_FD), maximum(dydeta_FD))
    # @printf("min(dydeta_num) = %1.6f --- max(dydeta_num) = %1.6f\n", minimum(dydeta_num), maximum(dydeta_num))
    return nothing
end

function MainSource()
    adapt_mesh = true
    visu     = true
    printfig = false  # print figures to disk
    path     = "./runs/"
    juliadivcmap    = zeros(RGB{Float64}, 5)
    juliadivcmap[1] = RGBA{Float64}(0/255,150/255,0/255, 1.)  
    juliadivcmap[2] = RGBA{Float64}(0/255,0/255,200/255, 1.)  
    juliadivcmap[3] = RGBA{Float64}(255/255,255/255,255/255, 1.) 
    juliadivcmap[4] = RGBA{Float64}(150/255,0/255,150/255, 1.) 
    juliadivcmap[5] = RGBA{Float64}(200/255,0/255,0/255, 1.)
    wave_colors     = cgrad(juliadivcmap, length(juliadivcmap), categorical=false, rev=false)
    
    # Spatial extent
    l  = (x = 25, y = 25)
    x  = (min=-l.x/2, max=l.x/2)
    y  = (min=-l.y/1, max=0.)

    # Discretization
    Nc  = (x = 50, y = 50) 
    Œî   = (Œæ = l.x/Nc.x, Œ∑ = l.y/Nc.y, Œ∂ = 1.0)
    X   = (v = (x = LinRange(x.min,       x.max,       Nc.x+1) , y = LinRange(y.min,       y.max,Nc.y+1)),
           c = (x = LinRange(x.min-Œî.Œæ/2, x.max+Œî.Œæ/2, Nc.x+2) , y = LinRange(y.min-Œî.Œ∑/2, y.max+Œî.Œ∑/2,Nc.y+2)),
           i = (x = LinRange(x.min,       x.max,       Nc.x+1) , y = LinRange(y.min-Œî.Œ∑/2, y.max+Œî.Œ∑/2,Nc.y+2)),
           j = (x = LinRange(x.min-Œî.Œæ/2, x.max+Œî.Œæ/2, Nc.x+2) , y = LinRange(y.min,       y.max,Nc.y+1))) 
        
    # Source parameters
    ùëì‚ÇÄ   = 100   # Central frequency of the source [Hz]
    t‚ÇÄ   = 1.2/ùëì‚ÇÄ
    œÉ‚ÇÄ   = l.x/100
    x‚ÇÄ   = (x.min + x.max)/2
    y‚ÇÄ   = (y.min + y.max)/2
    src  = (i=Int((Nc.x/2)+1),j=Int((Nc.y/2)+1))
    facS = (v=(x=0.0,y=1.0,z=1.0),c=(x=0.0,y=1.0,z=1.0))
    
    # Mechanical parameters 
    œÅ‚ÇÄ      = 1500.0
    K‚ÇÄ      = 1.e9
    G‚ÇÄ      = 1.e8
    De_s    = 1e-2 # Shear Deborah number
    Œ∑‚Çò‚ÇÄ     = De_s*G‚ÇÄ / ùëì‚ÇÄ
    Fb_b    = 1e-2 # Bulk Fatboy number
    Œ∑‚Çñ‚ÇÄ     = Fb_b*K‚ÇÄ / ùëì‚ÇÄ
   # DevRheo = :MaxwellVE #:Elastic or :MaxwellVE
    VolRheo = :KelvinVE  #:Elastic or :KelvinVE 
    
    DevRheo = :Elastic #or :MaxwellVE
    #VolRheo = :Elastic #or :KelvinVE 

    # Time domain
    c_eff = sqrt((K‚ÇÄ*(1+Fb_b)+4/3*G‚ÇÄ)/œÅ‚ÇÄ) 
    Œît    = min(1e10, 0.1*Œî.Œæ/c_eff, 0.1*Œî.Œ∑/c_eff ) # Courant criteria from wavespeed
    Nt    = 1000
    Nout  = 1000
    t     = -t‚ÇÄ
   
    # Storage on centers # +2 for ghost nodes for BCs
    szv   = (Nc.x+1, Nc.y+1)
    szc   = (Nc.x+2, Nc.y+2)
    szi   = (Nc.x+1, Nc.y+2)
    szj   = (Nc.x+2, Nc.y+1)
    # Storage on i and j meshes
    K     = (i= ones(szi)*K‚ÇÄ,  j= ones(szj)*K‚ÇÄ ) 
    G     = (i= ones(szi)*G‚ÇÄ,  j= ones(szj)*G‚ÇÄ ) 
    Œ∑‚Çò    = (i= ones(szi)*Œ∑‚Çò‚ÇÄ , j= ones(szj)*Œ∑‚Çò‚ÇÄ)
    Œ∑‚Çñ    = (i= ones(szi)*Œ∑‚Çñ‚ÇÄ , j= ones(szj)*Œ∑‚Çñ‚ÇÄ )
    ‚àáV    = (i=zeros(szi),     j=zeros(szj))
    P     = (i=zeros(szi),     j=zeros(szj))
    P0    = (i=zeros(szi),     j=zeros(szj))
    L     = (i=(xx=zeros(szi), xy=zeros(szi), yx=zeros(szi), yy=zeros(szi),zx=zeros(szi),zy=zeros(szi)),
             j=(xx=zeros(szj), xy=zeros(szj), yx=zeros(szj), yy=zeros(szj),zx=zeros(szj),zy=zeros(szj)))
    ŒµÃá     = (i=(xx=zeros(szi), yy=zeros(szi), zz=zeros(szi), xy=zeros(szi),xz=zeros(szi),yz=zeros(szi)),
             j=(xx=zeros(szj), yy=zeros(szj), zz=zeros(szj), xy=zeros(szj),xz=zeros(szj),yz=zeros(szj))) 
    œÑ     = (i=(xx=zeros(szi), yy=zeros(szi), zz=zeros(szi), xy=zeros(szi),xz=zeros(szi),yz=zeros(szi)),
             j=(xx=zeros(szj), yy=zeros(szj), zz=zeros(szj), xy=zeros(szj),xz=zeros(szj),yz=zeros(szj))) 
    œÑ0    = (i=(xx=zeros(szi), yy=zeros(szi), zz=zeros(szi), xy=zeros(szi),xz=zeros(szi),yz=zeros(szi)),
             j=(xx=zeros(szj), yy=zeros(szj), zz=zeros(szj), xy=zeros(szj),xz=zeros(szj),yz=zeros(szj)))                   

    # Storage on v and c meshes
    V     = ( v=(x=zeros(szv), y=zeros(szv), z=zeros(szv)),
              c=(x=zeros(szc), y=zeros(szc), z=zeros(szc)))

    œÅ     = (v=ones(szv)*œÅ‚ÇÄ, c=ones(szc)*œÅ‚ÇÄ)
    f_ext = (v=zeros(szv)  , c=zeros(szc))
    # BC
    Lbc        = 1.
    # BC on v and c mesh
    bc_filt_V   = (v=Cerjean2D(X.v,Lbc,l,Œî),c=Cerjean2D(X.c,Lbc,l,Œî))
    bc_filt_tau = (i=Cerjean2D(X.i,Lbc,l,Œî),j=Cerjean2D(X.j,Lbc,l,Œî))

    # Compute Ricker function with 2D spatial support
    f_ext  = (v=zeros(szv)  , c=zeros(szc))
    xc2d   = X.c.x * ones(size( X.c.y))'
    yc2d   = ones(size( X.c.x)) * X.c.y'
    xv2d   = X.v.x * ones(size( X.v.y))'
    yv2d   = ones(size( X.v.x)) * X.v.y'

    # Select deviatoric rheology
    if DevRheo == :Elastic
        devi = (G.i,Œît)
        devj = (G.j,Œît)
    elseif DevRheo == :MaxwellVE
        devi = (G.i,Œ∑‚Çò.i,Œît)
        devj = (G.j,Œ∑‚Çò.j,Œît)
    end

    # Select volumetric rheology
    if VolRheo == :Elastic
        voli = (K.i,Œît)
        volj = (K.j,Œît)
    elseif VolRheo == :KelvinVE
        voli = (K.i,Œ∑‚Çñ.i,Œît)
        volj = (K.j,Œ∑‚Çñ.j,Œît)
    end
    # Initialisation
    xxv, yyv    = LinRange(x.min-Œî.Œæ/2, x.max+Œî.Œæ/2, 2Nc.x+3), LinRange(y.min-Œî.Œ∑/2, y.max+Œî.Œ∑/2, 2Nc.y+3)
    (xv4,yv4) = ([x for x=xxv,y=yyv], [y for x=xxv,y=yyv])
    ‚àÇŒæ‚àÇx =  ones(2Nc.x+3, 2Nc.y+3)
    ‚àÇŒæ‚àÇy = zeros(2Nc.x+3, 2Nc.y+3)
    ‚àÇŒ∑‚àÇx = zeros(2Nc.x+3, 2Nc.y+3)
    ‚àÇŒ∑‚àÇy =  ones(2Nc.x+3, 2Nc.y+3)
    hx   = zeros(2Nc.x+3, 2Nc.y+3)
    if adapt_mesh
        x0     = (x.min + x.max)/2
        m      = y.min
        Amp    = 2.0
        œÉ      = 0.9
        œÉx     = 0.1
        œÉy     = 0.1
        œµ      = 1e-7
        # copy initial y
        x_ini  = copy(xv4)
        y_ini  = copy(yv4)
        X_msh  = zeros(2)
        # Compute slope
        hx     = -dhdx.(x_ini, Amp, œÉ, y.max, x0)
        # Deform mesh
        for i in eachindex(x_ini)          
            X_msh[1] = x_ini[i]
            X_msh[2] = y_ini[i]     
            xv4[i]   =  Mesh_x( X_msh,  Amp, x0, œÉ, y.max, m, x.min, x.max, œÉx )
            yv4[i]   =  Mesh_y( X_msh,  Amp, x0, œÉ, y.max, m, y.min, y.max, œÉy )
        end
        # Compute forward transformation
        # params = (Amp=Amp, x0=x0, œÉ=œÉ, m=m, xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, œÉx=œÉx, œÉy=œÉy, œµ=œµ)
        ‚àÇx     = (‚àÇŒæ=zeros(size(yv4)), ‚àÇŒ∑ = zeros(size(yv4)) )
        ‚àÇy     = (‚àÇŒæ=zeros(size(yv4)), ‚àÇŒ∑ = zeros(size(yv4)) )
        ComputeForwardTransformation_ini!( ‚àÇx, ‚àÇy, x_ini, y_ini, X_msh, Amp, x0, œÉ, m, x, y, œÉx, œÉy, œµ)
        # Solve for inverse transformation
        ‚àÇŒæ = (‚àÇx=‚àÇŒæ‚àÇx, ‚àÇy=‚àÇŒæ‚àÇy); ‚àÇŒ∑ = (‚àÇx=‚àÇŒ∑‚àÇx, ‚àÇy=‚àÇŒ∑‚àÇy)
        InverseJacobian!(‚àÇŒæ,‚àÇŒ∑,‚àÇx,‚àÇy)
        ‚àÇŒæ‚àÇx .= ‚àÇŒæ.‚àÇx; ‚àÇŒæ‚àÇy .= ‚àÇŒæ.‚àÇy
        ‚àÇŒ∑‚àÇx .= ‚àÇŒ∑.‚àÇx; ‚àÇŒ∑‚àÇy .= ‚àÇŒ∑.‚àÇy
    end
    ‚àÇŒæ‚àÇx1 = (
        i = ‚àÇŒæ‚àÇx[3:2:end-2,2:2:end-1],
        j = ‚àÇŒæ‚àÇx[3:2:end-2,2:2:end-1],
        c = ‚àÇŒæ‚àÇx[1:2:end-0,1:2:end-0],
        v = ‚àÇŒæ‚àÇx[2:2:end-1,2:2:end-1],
    )  
    ‚àÇŒ∑‚àÇx1 = (
        i = ‚àÇŒ∑‚àÇx[3:2:end-2,2:2:end-1],
        j = ‚àÇŒ∑‚àÇx[3:2:end-2,2:2:end-1],
        c = ‚àÇŒ∑‚àÇx[1:2:end-0,1:2:end-0],
        v = ‚àÇŒ∑‚àÇx[2:2:end-1,2:2:end-1],
    ) 
    ‚àÇŒæ‚àÇy1 = (
        i = ‚àÇŒæ‚àÇy[3:2:end-2,2:2:end-1],
        j = ‚àÇŒæ‚àÇy[3:2:end-2,2:2:end-1],
        c = ‚àÇŒæ‚àÇy[1:2:end-0,1:2:end-0],
        v = ‚àÇŒæ‚àÇy[2:2:end-1,2:2:end-1],
    )  
    ‚àÇŒ∑‚àÇy1 = (
        i = ‚àÇŒ∑‚àÇy[3:2:end-2,2:2:end-1],
        j = ‚àÇŒ∑‚àÇy[3:2:end-2,2:2:end-1],
        c = ‚àÇŒ∑‚àÇy[1:2:end-0,1:2:end-0],
        v = ‚àÇŒ∑‚àÇy[2:2:end-1,2:2:end-1],
    )
    # Time loop
    @views @time for it=1:Nt

        # Update Time
        t += Œît
        P0.i .= P.i
        P0.j .= P.j

        œÑ0.i.xx .= œÑ.i.xx
        œÑ0.i.xy .= œÑ.i.xy
        œÑ0.i.xz .= œÑ.i.xz
        œÑ0.i.yy .= œÑ.i.yy
        œÑ0.i.zz .= œÑ.i.zz
        œÑ0.i.yz .= œÑ.i.yz

        œÑ0.j.xx .= œÑ.j.xx
        œÑ0.j.xy .= œÑ.j.xy
        œÑ0.j.xz .= œÑ.j.xz
        œÑ0.j.yy .= œÑ.j.yy
        œÑ0.j.zz .= œÑ.j.zz
        œÑ0.j.yz .= œÑ.j.yz 
        
        # 2D Ricker with spatial support
        @.. f_ext.c = œÅ.c*Ricker.( xc2d, x‚ÇÄ, yc2d, y‚ÇÄ, t, t‚ÇÄ, ùëì‚ÇÄ, œÉ‚ÇÄ)
        @.. f_ext.v = œÅ.v*Ricker.( xv2d, x‚ÇÄ, yv2d, y‚ÇÄ, t, t‚ÇÄ, ùëì‚ÇÄ, œÉ‚ÇÄ)
        
        # Inherited pressure (remove the instantaneous viscous contribution )
       
        @.. P0.i = P0.i + œáb(voli...)*‚àáV.i 
        @.. P0.j = P0.j + œáb(volj...)*‚àáV.j

        # Inherited deviatoric stress (remove the instantaneous viscous contribution)
        @.. œÑ0.i.xx= œÑ0.i.xx - œás(devi...)*ŒµÃá.i.xx
        @.. œÑ0.i.xy= œÑ0.i.xy - œás(devi...)*ŒµÃá.i.xy
        @.. œÑ0.i.xz= œÑ0.i.xz - œás(devi...)*ŒµÃá.i.xz
        @.. œÑ0.i.yy= œÑ0.i.yy - œás(devi...)*ŒµÃá.i.yy
        @.. œÑ0.i.zz= œÑ0.i.zz - œás(devi...)*ŒµÃá.i.zz
        @.. œÑ0.i.yz= œÑ0.i.yz - œás(devi...)*ŒµÃá.i.yz
       
        @.. œÑ0.j.xx= œÑ0.j.xx - œás(devj...)*ŒµÃá.j.xx
        @.. œÑ0.j.xy= œÑ0.j.xy - œás(devj...)*ŒµÃá.j.xy
        @.. œÑ0.j.xz= œÑ0.j.xz - œás(devj...)*ŒµÃá.j.xz
        @.. œÑ0.j.yy= œÑ0.j.yy - œás(devj...)*ŒµÃá.j.yy
        @.. œÑ0.j.zz= œÑ0.j.zz - œás(devj...)*ŒµÃá.j.zz
        @.. œÑ0.j.yz= œÑ0.j.yz - œás(devj...)*ŒµÃá.j.yz

        # Velocity gradient components
        @.. L.i.xx[:,2:end-1] = ‚àÇŒæ‚àÇx1.i * (V.c.x[2:end,2:end-1] - V.c.x[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.i * (V.v.x[ :     ,2:end] - V.v.x[ :     ,1:end-1])/Œî.Œ∑
        @.. L.j.xx[2:end-1,:] = ‚àÇŒæ‚àÇx1.j * (V.v.x[2:end, :     ] - V.v.x[1:end-1, :     ])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.j * (V.c.x[2:end-1,2:end] - V.c.x[2:end-1,1:end-1])/Œî.Œ∑

        @.. L.i.yx[:,2:end-1] = ‚àÇŒæ‚àÇx1.i * (V.c.y[2:end,2:end-1] - V.c.y[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.i * (V.v.y[ :     ,2:end] - V.v.y[ :     ,1:end-1])/Œî.Œ∑
        @.. L.j.yx[2:end-1,:] = ‚àÇŒæ‚àÇx1.j * (V.v.y[2:end, :     ] - V.v.y[1:end-1, :     ])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.j * (V.c.y[2:end-1,2:end] - V.c.y[2:end-1,1:end-1])/Œî.Œ∑

        @.. L.i.yy[:,2:end-1] = ‚àÇŒæ‚àÇy1.i * (V.c.y[2:end,2:end-1] - V.c.y[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.i * (V.v.y[ :     ,2:end] - V.v.y[ :     ,1:end-1])/Œî.Œ∑
        @.. L.j.yy[2:end-1,:] = ‚àÇŒæ‚àÇy1.j * (V.v.y[2:end, :     ] - V.v.y[1:end-1, :     ])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.j * (V.c.y[2:end-1,2:end] - V.c.y[2:end-1,1:end-1])/Œî.Œ∑

        @.. L.i.xy[:,2:end-1] = ‚àÇŒæ‚àÇy1.i * (V.c.x[2:end,2:end-1] - V.c.x[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.i * (V.v.x[ :,     2:end] - V.v.x[ :     ,1:end-1])/Œî.Œ∑
        @.. L.j.xy[2:end-1,:] = ‚àÇŒæ‚àÇy1.j * (V.v.x[2:end, :     ] - V.v.x[1:end-1, :     ])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.j * (V.c.x[2:end-1,2:end] - V.c.x[2:end-1,1:end-1])/Œî.Œ∑

        @.. L.i.zy[:,2:end-1] = (V.v.z[ :     ,2:end] - V.v.z[ :     ,1:end-1])/Œî.Œ∑
        @.. L.j.zy[2:end-1,:] = (V.c.z[2:end-1,2:end] - V.c.z[2:end-1,1:end-1])/Œî.Œ∑

        @.. L.i.zx[:,2:end-1] = (V.c.z[2:end,2:end-1] - V.c.z[1:end-1,2:end-1])/Œî.Œæ
        @.. L.j.zx[2:end-1,:] = (V.v.z[2:end, :     ] - V.v.z[1:end-1, :     ])/Œî.Œæ
        
        # Divergence
        @.. ‚àáV.i   = L.i.xx + L.i.yy
        @.. ‚àáV.j   = L.j.xx + L.j.yy

        # Deviatoric strain rate 
        @.. ŒµÃá.i.xx = L.i.xx - 1//3*‚àáV.i
        @.. ŒµÃá.j.xx = L.j.xx - 1//3*‚àáV.j

        @.. ŒµÃá.i.yy = L.i.yy - 1//3*‚àáV.i
        @.. ŒµÃá.j.yy = L.j.yy - 1//3*‚àáV.j

        @.. ŒµÃá.i.zz = - 1//3*‚àáV.i
        @.. ŒµÃá.j.zz = - 1//3*‚àáV.j

        @.. ŒµÃá.i.xy = 1//2*(L.i.xy + L.i.yx)
        @.. ŒµÃá.j.xy = 1//2*(L.j.xy + L.j.yx)
        
        # in 2D Lxz and Lyz are zero 
        @.. ŒµÃá.i.xz = 1//2*(L.i.zx)
        @.. ŒµÃá.j.xz = 1//2*(L.j.zx)

        @.. ŒµÃá.i.yz = 1//2*(L.i.zy)
        @.. ŒµÃá.j.yz = 1//2*(L.j.zy)
      
        # Stress update
        @.. œÑ.i.xx = Œ∑s(devi...)*(ŒµÃá.i.xx) + Œ∏s(devi...)*œÑ0.i.xx
        @.. œÑ.j.xx = Œ∑s(devj...)*(ŒµÃá.j.xx) + Œ∏s(devj...)*œÑ0.j.xx

        @.. œÑ.i.yy = Œ∑s(devi...)*(ŒµÃá.i.yy) + Œ∏s(devi...)*œÑ0.i.yy
        @.. œÑ.j.yy = Œ∑s(devj...)*(ŒµÃá.j.yy) + Œ∏s(devj...)*œÑ0.j.yy
        
        @.. œÑ.i.zz = Œ∑s(devi...)*(ŒµÃá.i.zz) + Œ∏s(devi...)*œÑ0.i.zz
        @.. œÑ.j.zz = Œ∑s(devj...)*(ŒµÃá.j.zz) + Œ∏s(devj...)*œÑ0.j.zz
        
        @.. œÑ.i.xy = Œ∑s(devi...)*(ŒµÃá.i.xy) + Œ∏s(devi...)*œÑ0.i.xy
        @.. œÑ.j.xy = Œ∑s(devj...)*(ŒµÃá.j.xy) + Œ∏s(devj...)*œÑ0.j.xy
        
        @.. œÑ.i.xz = Œ∑s(devi...)*(ŒµÃá.i.xz) + Œ∏s(devi...)*œÑ0.i.xz
        @.. œÑ.j.xz = Œ∑s(devj...)*(ŒµÃá.j.xz) + Œ∏s(devj...)*œÑ0.j.xz
        
        @.. œÑ.i.yz = Œ∑s(devi...)*(ŒµÃá.i.yz) + Œ∏s(devi...)*œÑ0.i.yz
        @.. œÑ.j.yz = Œ∑s(devj...)*(ŒµÃá.j.yz) + Œ∏s(devj...)*œÑ0.j.yz

        # Pressure update 
        @.. P.i    = Œ∏b(voli...)*P0.i - Œ∑b(voli...)*‚àáV.i 
        @.. P.j    = Œ∏b(volj...)*P0.j - Œ∑b(volj...)*‚àáV.j 

        # @show size(œÑ.j.xx[3:end-1,2:end-1])
        # @show size(V.v.x[2:end-1,2:end-1])
        # @show size(‚àÇŒæ‚àÇx1.v[2:end-1,2:end-1])

        # @show size(œÑ.i.xx[2:end,2:end-1])
        # @show size(V.c.x[2:end-1,2:end-1])
        # @show size(‚àÇŒæ‚àÇx1.c[2:end-1,2:end-1])

        # Linear momentum balance
        @. V.v.x[2:end-1,2:end-1] = (V.v.x[2:end-1,2:end-1] 
                                    + Œît/œÅ.v[2:end-1,2:end-1]
                                    *( ‚àÇŒæ‚àÇx1.v[2:end-1,2:end-1] * (œÑ.j.xx[3:end-1,2:end-1]-œÑ.j.xx[2:end-2,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.v[2:end-1,2:end-1] * (œÑ.i.xx[2:end-1,3:end-1]-œÑ.i.xx[2:end-1,2:end-2])/Œî.Œ∑
                                    +  ‚àÇŒæ‚àÇy1.v[2:end-1,2:end-1] * (œÑ.j.xy[3:end-1,2:end-1]-œÑ.j.xy[2:end-2,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.v[2:end-1,2:end-1] * (œÑ.i.xy[2:end-1,3:end-1]-œÑ.i.xy[2:end-1,2:end-2])/Œî.Œ∑ 
                                    -  ‚àÇŒæ‚àÇx1.v[2:end-1,2:end-1] * (   P.j[3:end-1,2:end-1]-   P.j[2:end-2,2:end-1])/Œî.Œæ - ‚àÇŒ∑‚àÇx1.v[2:end-1,2:end-1] * (   P.i[2:end-1,3:end-1]-   P.i[2:end-1,2:end-2])/Œî.Œ∑  
                                    -  facS.v.x*f_ext.v[2:end-1,2:end-1]))
        @. V.c.x[2:end-1,2:end-1] = (V.c.x[2:end-1,2:end-1] 
                                    + Œît/œÅ.c[2:end-1,2:end-1]
                                    *( ‚àÇŒæ‚àÇx1.c[2:end-1,2:end-1] * (œÑ.i.xx[2:end,2:end-1]-œÑ.i.xx[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.c[2:end-1,2:end-1] * (œÑ.j.xx[2:end-1,2:end]-œÑ.j.xx[2:end-1,1:end-1])/Œî.Œ∑ 
                                    +  ‚àÇŒæ‚àÇy1.c[2:end-1,2:end-1] * (œÑ.i.xy[2:end,2:end-1]-œÑ.i.xy[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.c[2:end-1,2:end-1] * (œÑ.j.xy[2:end-1,2:end]-œÑ.j.xy[2:end-1,1:end-1])/Œî.Œ∑
                                    -  ‚àÇŒæ‚àÇx1.c[2:end-1,2:end-1] * (   P.i[2:end,2:end-1]-   P.i[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.c[2:end-1,2:end-1] * (   P.j[2:end-1,2:end]-   P.j[2:end-1,1:end-1])/Œî.Œ∑ 
                                    -  facS.c.x*f_ext.c[2:end-1,2:end-1]))                            

        @. V.v.y[2:end-1,2:end-1] = (V.v.y[2:end-1,2:end-1] 
                                    + Œît/œÅ.v[2:end-1,2:end-1]
                                    *( ‚àÇŒæ‚àÇx1.v[2:end-1,2:end-1] * (œÑ.j.xy[3:end-1,2:end-1]-œÑ.j.xy[2:end-2,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.v[2:end-1,2:end-1] * (œÑ.i.xy[2:end-1,3:end-1]-œÑ.i.xy[2:end-1,2:end-2])/Œî.Œ∑ 
                                    +  ‚àÇŒæ‚àÇy1.v[2:end-1,2:end-1] * (œÑ.j.yy[3:end-1,2:end-1]-œÑ.j.yy[2:end-2,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.v[2:end-1,2:end-1] * (œÑ.i.yy[2:end-1,3:end-1]-œÑ.i.yy[2:end-1,2:end-2])/Œî.Œ∑ 
                                    -  ‚àÇŒæ‚àÇy1.v[2:end-1,2:end-1] * (   P.j[3:end-1,2:end-1]-   P.j[2:end-2,2:end-1])/Œî.Œæ - ‚àÇŒ∑‚àÇy1.v[2:end-1,2:end-1] * (   P.i[2:end-1,3:end-1]-   P.i[2:end-1,2:end-2])/Œî.Œ∑ 
                                    -  facS.v.y*f_ext.v[2:end-1,2:end-1]))
        
        @.. V.c.y[2:end-1,2:end-1] = (V.c.y[2:end-1,2:end-1] 
                                    + Œît/œÅ.c[2:end-1,2:end-1]
                                    *( ‚àÇŒæ‚àÇx1.c[2:end-1,2:end-1] * (œÑ.i.xy[2:end,2:end-1]-œÑ.i.xy[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇx1.c[2:end-1,2:end-1] * (œÑ.j.xy[2:end-1,2:end]-œÑ.j.xy[2:end-1,1:end-1])/Œî.Œ∑
                                    +  ‚àÇŒæ‚àÇy1.c[2:end-1,2:end-1] * (œÑ.i.yy[2:end,2:end-1]-œÑ.i.yy[1:end-1,2:end-1])/Œî.Œæ + ‚àÇŒ∑‚àÇy1.c[2:end-1,2:end-1] * (œÑ.j.yy[2:end-1,2:end]-œÑ.j.yy[2:end-1,1:end-1])/Œî.Œ∑ 
                                    -  ‚àÇŒæ‚àÇy1.c[2:end-1,2:end-1] * (   P.i[2:end,2:end-1]-   P.i[1:end-1,2:end-1])/Œî.Œæ - ‚àÇŒ∑‚àÇy1.c[2:end-1,2:end-1] * (P.j[2:end-1,2:end]-P.j[2:end-1,1:end-1])/Œî.Œ∑ 
                                    -  facS.c.y*f_ext.c[2:end-1,2:end-1]))   

        # the two terms in dPdz and dtauzzdz  cancel in linear elastic case ... but i am not sure with other rheologies so I have left them 
        @.. V.v.z[2:end-1,2:end-1] = (V.v.z[2:end-1,2:end-1] 
                                    + Œît/œÅ.v[2:end-1,2:end-1]
                                    *( (œÑ.j.xz[3:end-1,2:end-1]-œÑ.j.xz[2:end-2,2:end-1])/Œî.Œæ
                                    +  (œÑ.i.yz[2:end-1,3:end-1]-œÑ.i.yz[2:end-1,2:end-2])/Œî.Œ∑ 
                                    -  facS.v.z* f_ext.v[2:end-1,2:end-1]))
        
        @.. V.c.z[2:end-1,2:end-1] = (V.c.z[2:end-1,2:end-1] 
                                    + Œît/œÅ.c[2:end-1,2:end-1]
                                    *( (œÑ.i.xz[2:end,2:end-1]-œÑ.i.xz[1:end-1,2:end-1])/Œî.Œæ
                                    +  (œÑ.j.yz[2:end-1,2:end]-œÑ.j.yz[2:end-1,1:end-1])/Œî.Œ∑ 
                                    -  facS.c.z*f_ext.c[2:end-1,2:end-1]))   
    
        # Absorbing boundary Cerjean et al. (1985)
        @..  V.v.x  = V.v.x  * bc_filt_V.v 
        @..  V.v.y  = V.v.y  * bc_filt_V.v 
        @..  V.v.z  = V.v.z  * bc_filt_V.v
        @..  V.c.x  = V.c.x  * bc_filt_V.c 
        @..  V.c.y  = V.c.y  * bc_filt_V.c 
        @..  V.c.z  = V.c.z  * bc_filt_V.c  

        @..  P.i    = P.i    *  bc_filt_tau.i 
        @..  œÑ.i.xx = œÑ.i.xx *  bc_filt_tau.i
        @..  œÑ.i.yy = œÑ.i.yy *  bc_filt_tau.i
        @..  œÑ.i.zz = œÑ.i.zz *  bc_filt_tau.i
        @..  œÑ.i.xy = œÑ.i.xy *  bc_filt_tau.i
        @..  œÑ.i.xz = œÑ.i.xz *  bc_filt_tau.i
        @..  œÑ.i.yz = œÑ.i.yz *  bc_filt_tau.i

        @..  P.j    = P.j    *  bc_filt_tau.j 
        @..  œÑ.j.xx = œÑ.j.xx *  bc_filt_tau.j
        @..  œÑ.j.yy = œÑ.j.yy *  bc_filt_tau.j
        @..  œÑ.j.zz = œÑ.j.zz *  bc_filt_tau.j
        @..  œÑ.j.xy = œÑ.j.xy *  bc_filt_tau.j
        @..  œÑ.j.xz = œÑ.j.xz *  bc_filt_tau.j
        @..  œÑ.j.yz = œÑ.j.yz *  bc_filt_tau.j

        # Visualisation
        if mod(it, Nout)==0 && visu==true
            xv2_1, yv2_1 = xv4[2:2:end-1,2:2:end-1  ], yv4[2:2:end-1,2:2:end-1  ]
            xv2_2, yv2_2 = xv4[1:2:end-0,1:2:end-0  ], yv4[1:2:end-0,1:2:end-0  ]
            xc2_1, yc2_1 = xv4[3:2:end-2,2:2:end-1  ], yv4[3:2:end-2,2:2:end-1  ]
            xc2_2, yc2_2 = xv4[2:2:end-1,3:2:end-2+2], yv4[2:2:end-1,3:2:end-2+2]
            vertx = [  xv2_1[1:end-1,1:end-1][:]  xv2_1[2:end-0,1:end-1][:]  xv2_1[2:end-0,2:end-0][:]  xv2_1[1:end-1,2:end-0][:] ] 
            verty = [  yv2_1[1:end-1,1:end-1][:]  yv2_1[2:end-0,1:end-1][:]  yv2_1[2:end-0,2:end-0][:]  yv2_1[1:end-1,2:end-0][:] ] 
            PatchPlotMakie(vertx, verty, V.c.x[2:end-1,2:end-1][:]; cmap=wave_colors )
            sleep(0.1)
            if printfig Print2Disk( f, path, "Vall", it) end
        end
    end
end

function Cerjean2D(X, Lbc, l, Œî)
    return ((1.0 .- exp.(-(X.x*ones(size(X.y))'.-0*l.x).^2/Lbc.^2))
         .*(1.0 .- exp.(-(X.x*ones(size(X.y))' .-  l.x).^2/Lbc.^2)) )
        #  .*(1.0 .- exp.(-(ones(size(X.x))*X.y' .-0*l.y).^2/Lbc.^2)) )
        #  .*(1.0 .- exp.(-(ones(size(X.x))*X.y' .-  l.y).^2/Lbc.^2)))
end

function Print2Disk( f, path, field, istep; res=4)
    path1 = path*"/_$field/"
    mkpath(path1)
    save(path1*"$field"*@sprintf("%05d", istep)*".png", f, px_per_unit = res) 
end

MainSource()